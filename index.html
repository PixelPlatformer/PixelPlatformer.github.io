<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena Royale: 4-Player v1.9.0</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Tiny5&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #080808; color: #fff; font-family: 'Tiny5', sans-serif; overflow: hidden; cursor: crosshair; }
        #bg-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        canvas#gameCanvas { display: none; background: #12121e; width: 100vw; height: 100vh; image-rendering: pixelated; }

        .neon-glow { color: #fff; text-shadow: 0 0 10px #fff, 0 0 20px #00d2ff; }
        .menu-screen { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; display: none; z-index: 100; min-width: 400px;
            background: rgba(10,10,15,0.98); padding: 40px; border: 2px solid #fff;
            box-shadow: 0 0 30px rgba(255,255,255,0.1);
        }
        #main-menu { display: block; }
        .btn { background: #000; color: #fff; border: 1px solid #fff; padding: 12px 20px; font-family: 'Tiny5'; font-size: 22px; cursor: pointer; margin: 10px 0; text-transform: uppercase; width: 100%; transition: 0.2s; }
        .btn:hover { background: #fff; color: #000; box-shadow: 0 0 20px #fff; }
        input { background: #000; color: #fff; border: 1px solid #fff; font-family: 'Tiny5'; font-size: 20px; padding: 10px; width: 100%; text-align: center; box-sizing: border-box; outline: none; }

        #victory-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: center; }
        #warmup-overlay { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; color: #fff; text-shadow: 0 0 30px #00d2ff; z-index: 150; display: none; pointer-events: none; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; z-index: 20; }
        #match-info { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: 28px; }
        #scoreboard { position: absolute; top: 20px; right: 20px; text-align: right; }
        #inv-slot { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 90px; height: 90px; background: rgba(0,0,0,0.8); border: 2px solid #fff; display: flex; align-items: center; justify-content: center; font-size: 14px; pointer-events: auto; }
        #admin-panel { position: absolute; top: 80px; left: 20px; background: rgba(0,0,0,0.9); border: 1px solid red; padding: 15px; pointer-events: auto; display: none; }
    </style>
</head>
<body>
    <div id="version-tag" style="position:fixed; bottom:10px; left:10px; font-size:14px; color:rgba(255,255,255,0.3);">v1.9.0</div>

    <canvas id="bg-canvas"></canvas>
    
    <div id="main-menu" class="menu-screen">
        <h1 class="neon-glow" style="font-size: 55px; margin-bottom: 25px;">ARENA ROYALE</h1>
        <input type="text" id="player-name-input" placeholder="DISPLAY NAME" maxlength="12">
        <button class="btn" onclick="setupHost()">HOST SERVER</button>
        <button class="btn" onclick="showMenu('join-menu')">JOIN SERVER</button>
    </div>

    <div id="join-menu" class="menu-screen">
        <h2 class="neon-glow">CONNECTION</h2>
        <input type="text" id="join-code-input" placeholder="4-LETTER KEY">
        <button class="btn" onclick="joinGame()">LINK START</button>
        <button class="btn" onclick="showMenu('main-menu')">CANCEL</button>
    </div>

    <div id="host-lobby" class="menu-screen">
        <h2 class="neon-glow">LOBBY ID: <span id="host-code-display" style="color: #ff4500;">...</span></h2>
        <div id="player-list" style="margin: 25px 0; color: #fff; text-align: left;">
            <div id="p1-slot">1. (You)</div>
            <div id="p2-slot">2. Waiting...</div>
            <div id="p3-slot">3. Waiting...</div>
            <div id="p4-slot">4. Waiting...</div>
        </div>
        <button class="btn" onclick="triggerStart()" id="start-btn" disabled style="opacity:0.3;">ENTER ARENA</button>
        <button class="btn" onclick="location.reload()">ABANDON</button>
    </div>

    <div id="warmup-overlay">3</div>

    <div id="victory-screen">
        <h1 class="neon-glow" style="font-size: 80px;">ROUND END</h1>
        <h2 id="winner-name" style="font-size: 50px; color: #00ffcc;">PLAYER NAME</h2>
    </div>

    <div id="ui-layer">
        <div id="match-info">ROUND <span id="round-num">1</span>/5</div>
        <div id="scoreboard"></div>
        <div id="admin-panel">
            <button class="btn" style="font-size:14px;" onclick="toggleCheat('fly')">FLY</button>
            <button class="btn" style="font-size:14px;" onclick="toggleCheat('luck')">MAX LUCK</button>
        </div>
        <div id="inv-slot">EMPTY</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgCanvas = document.getElementById('bg-canvas');
    const bgCtx = bgCanvas.getContext('2d');

    // --- MODULAR BRIDGE MAP ---
    let PLATFORMS = [];
    function buildMap() {
        PLATFORMS = [];
        const segmentWidth = 140;
        const totalSegments = 20;
        const startX = -800;
        for(let i=0; i<totalSegments; i++) {
            PLATFORMS.push({ x: startX + (i * segmentWidth), y: 500, w: segmentWidth - 10, h: 60, contactTime: 0, falling: false, vy: 0 });
        }
    }

    const MAGMA_Y = 800;
    const GRAVITY = 0.55, JUMP = -13, BASE_SPEED = 2.2;

    let isGameRunning = false, isHost = false, connections = [], peer, myId;
    let mouseX = 0, mouseY = 0, myAngle = 0, magmaFrame = 0, warmupTime = 0;
    let projectiles = [], explosions = [], beams = [], droppedItems = [];
    let players = {}; // Object to hold all network players
    let scores = {};
    let cheatFly = false, cheatLuck = false, rollTimer = 0, attackTimer = 0;
    let currentRound = 1, isDead = false;

    const ME = { id: 'me', x: 0, y: 0, r: 22, vx: 0, vy: 0, rot: 0, item: null, name: 'ME', color: '#fff', swing: 0 };

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();
    function randColor() { return `hsl(${Math.random() * 360}, 75%, 65%)`; }

    // --- NETWORK ---
    function setupHost() {
        ME.name = document.getElementById('player-name-input').value || "P1";
        ME.color = randColor();
        myId = Math.random().toString(36).substr(2, 4).toUpperCase();
        document.getElementById('host-code-display').innerText = myId;
        showMenu('host-lobby');
        peer = new Peer(myId);
        peer.on('connection', c => {
            if (connections.length >= 3) return c.close();
            connections.push(c);
            c.on('open', () => {
                const pNum = connections.length + 1;
                document.getElementById(`p${pNum}-slot`).innerText = `${pNum}. Connected!`;
                document.getElementById('start-btn').disabled = false;
                document.getElementById('start-btn').style.opacity = "1";
                initConn(c);
            });
        });
        isHost = true;
    }

    function joinGame() {
        ME.name = document.getElementById('player-name-input').value || "GUEST";
        ME.color = randColor();
        const code = document.getElementById('join-code-input').value.toUpperCase();
        peer = new Peer();
        peer.on('open', () => {
            const c = peer.connect(code);
            connections.push(c);
            c.on('open', () => initConn(c));
        });
    }

    function initConn(c) {
        c.on('data', data => {
            if (data.type === 'START') startGame();
            if (data.type === 'SYNC_ROUND') syncRound(data.round);
            if (data.type === 'UPDATE') { players[data.id] = data.state; }
            if (data.type === 'VOID') { if(players[data.id]) players[data.id].dead = true; checkMatchEnd(); }
            if (data.type === 'HIT' && data.target === 'me') { ME.vx = data.vx; ME.vy = data.vy; }
            if (data.type === 'PROJ') projectiles.push(data.obj);
            if (data.type === 'EXPLODE') explosions.push({ x: data.x, y: data.y, r: 0, max: 250 });
            if (data.type === 'PLAT_STATE') { let p = PLATFORMS[data.idx]; p.contactTime = data.time; p.falling = data.fall; p.vy = data.vy; p.y = data.py; }
        });
    }

    function triggerStart() {
        connections.forEach(c => c.send({ type: 'START' }));
        startGame();
    }

    function startGame() {
        document.querySelectorAll('.menu-screen').forEach(e => e.style.display = 'none');
        document.getElementById('ui-layer').style.display = 'block';
        canvas.style.display = 'block';
        isGameRunning = true; 
        syncRound(1);
        requestAnimationFrame(gameLoop);
        setInterval(networkLoop, 30);
    }

    function syncRound(num) {
        currentRound = num; isDead = false; 
        warmupTime = 180; // 3 Seconds @ 60fps
        buildMap();
        // Dynamic spawn positions for 4 players
        const spawnX = [-200, 200, 600, 1000];
        const idx = isHost ? 0 : connections.length; // Simplified
        ME.x = spawnX[idx] || 0; ME.y = -100; ME.vx = 0; ME.vy = 0;
        Object.keys(players).forEach(k => players[k].dead = false);
        document.getElementById('victory-screen').style.display = 'none';
        updateUI();
    }

    function networkLoop() {
        if (!conn && connections.length === 0) return;
        const state = { x: ME.x, y: ME.y, rot: ME.rot, item: ME.item?.name || 'NOTHING', angle: myAngle, name: ME.name, color: ME.color, swing: ME.swing, dead: isDead };
        connections.forEach(c => c.send({ type: 'UPDATE', id: peer.id, state }));
    }

    // --- CONTROLS ---
    window.onkeydown = e => { 
        if(isDead || warmupTime > 0) return;
        if(e.key === ' ' && attackTimer <= 0) handleAttack();
        if(e.key === 'e') spinRNG();
        if(e.key === 'Shift' && rollTimer <= 0) roll();
        if(e.key === '/') { const p = prompt("ADMIN KEY:"); if(p === '67412') document.getElementById('admin-panel').style.display='block'; }
        keys[e.key.toLowerCase()] = true; 
    };
    const keys = {};
    window.onkeyup = e => keys[e.key.toLowerCase()] = false;
    window.onmousemove = e => { mouseX = e.clientX; mouseY = e.clientY; myAngle = Math.atan2(mouseY - ME.y, mouseX - ME.x); };

    function spinRNG() {
        if(ME.item) return;
        const items = [{ name: 'STICK', ammo: Infinity }, { name: 'SWORD', ammo: Infinity }, { name: 'SNOWBALL', ammo: 8 }, { name: 'NUKE', ammo: 1 }, { name: 'LASER', ammo: 10 }];
        let r = Math.random() * 100; if(cheatLuck) r = 0;
        let res = items[Math.floor(Math.random() * 3)];
        if(r < 10) res = items[3]; if(r < 3) res = items[4];
        ME.item = {...res}; updateUI();
    }

    function handleAttack() {
        if(!ME.item) { ME.swing = 10; attackTimer = 50; checkMeleeHit(70, 8); return; }
        const vx = Math.cos(myAngle), vy = Math.sin(myAngle);
        if (ME.item.name === 'STICK') { ME.swing = 15; attackTimer = 70; checkMeleeHit(90, 20); } 
        else if (ME.item.name === 'SWORD') { ME.swing = 20; attackTimer = 80; checkMeleeHit(150, 25); } 
        else if (ME.item.name === 'SNOWBALL') {
            const obj = { x: ME.x, y: ME.y, vx: vx * 13, vy: vy * 13, owner: peer.id, type: 'SNOW' };
            projectiles.push(obj); connections.forEach(c => c.send({ type: 'PROJ', obj }));
            ME.item.ammo--; attackTimer = 90;
        } else if (ME.item.name === 'NUKE') {
            const obj = { x: ME.x, y: ME.y, vx: vx * 6, vy: vy * 4, owner: peer.id, type: 'NUKE' };
            projectiles.push(obj); connections.forEach(c => c.send({ type: 'PROJ', obj }));
            ME.item.ammo--;
        }
        if (ME.item && ME.item.ammo <= 0) ME.item = null;
        updateUI();
    }

    function checkMeleeHit(range, force) {
        Object.keys(players).forEach(id => {
            const p = players[id];
            const d = Math.hypot(p.x - ME.x, p.y - ME.y);
            if (d < range && !p.dead) {
                connections.forEach(c => c.send({ type: 'HIT', target: id, vx: Math.cos(myAngle) * force, vy: -7 }));
            }
        });
    }

    function roll() { ME.vx = (mouseX > ME.x ? 1 : -1) * 18; rollTimer = 110; }
    function toggleCheat(c) { if(c==='fly') cheatFly=!cheatFly; if(c==='luck') cheatLuck=!cheatLuck; }

    // --- GAME ENGINE ---
    function update() {
        if (!isGameRunning) return;
        magmaFrame++;
        if (warmupTime > 0) {
            warmupTime--;
            const over = document.getElementById('warmup-overlay');
            over.style.display = 'block';
            over.innerText = Math.ceil(warmupTime/60);
            if(warmupTime === 0) { over.innerText = "GO!"; setTimeout(()=>over.style.display='none', 500); }
            return;
        }

        if(!isDead) {
            attackTimer--; rollTimer--; ME.swing--;
            if (keys['a']) { ME.vx = -BASE_SPEED; ME.rot -= 0.1; } else if (keys['d']) { ME.vx = BASE_SPEED; ME.rot += 0.1; } else { ME.vx *= 0.88; }
            if(!cheatFly) { if(keys['w'] && ME.grounded) ME.vy = JUMP; ME.vy += GRAVITY; } else { if(keys['w']) ME.vy = -5; else if(keys['s']) ME.vy = 5; else ME.vy = 0; }
            ME.x += ME.vx; ME.y += ME.vy;
            ME.grounded = false;

            PLATFORMS.forEach((p, idx) => {
                if(p.falling) { p.vy += 0.2; p.y += p.vy; }
                if (ME.vy >= 0 && ME.y + ME.r > p.y && ME.y + ME.r < p.y + 40 && ME.x > p.x && ME.x < p.x + p.w) {
                    ME.y = p.y - ME.r; ME.vy = 0; ME.grounded = true;
                    if(!p.falling) { 
                        p.contactTime++; 
                        if(p.contactTime > 300) p.falling = true;
                        if(isHost && p.contactTime % 15 === 0) connections.forEach(c => c.send({type:'PLAT_STATE', idx, time: p.contactTime, fall: p.falling, vy: p.vy, py: p.y}));
                    }
                }
            });

            if (ME.y > MAGMA_Y) { isDead = true; connections.forEach(c => c.send({type:'VOID', id: peer.id})); checkMatchEnd(); }
        }

        projectiles.forEach((p, i) => { 
            p.x += p.vx; p.y += p.vy; if(p.type==='NUKE') p.vy+=0.15;
            if (!isDead && Math.hypot(p.x-ME.x, p.y-ME.y)<35 && p.owner!==peer.id){ ME.vx=p.vx; ME.vy=-8; projectiles.splice(i,1); }
            PLATFORMS.forEach(plat => { if(p.type==='NUKE' && p.y > plat.y && p.x > plat.x && p.x < plat.x + plat.w) { explosions.push({x:p.x, y:p.y, r:0, max:250}); projectiles.splice(i,1); } });
        });

        explosions.forEach((e, i) => { e.r += 14; if (!isDead && Math.hypot(ME.x - e.x, ME.y - e.y) < e.r && e.r < 70) { ME.vx = (ME.x-e.x)*0.8; ME.vy=-18; } if (e.r > e.max) explosions.splice(i, 1); });
    }

    function checkMatchEnd() {
        if (!isHost) return;
        let alive = [];
        if (!isDead) alive.push(ME.name);
        Object.keys(players).forEach(id => { if(!players[id].dead) alive.push(players[id].name); });

        if (alive.length <= 1) {
            const winner = alive.length === 1 ? alive[0] : "DRAW";
            showWinner(winner);
            setTimeout(() => {
                if(currentRound < 5) { currentRound++; connections.forEach(c => c.send({type:'SYNC_ROUND', round:currentRound})); syncRound(currentRound); }
                else { alert("SERIES FINISHED!"); location.reload(); }
            }, 3000);
        }
    }

    function showWinner(name) { const screen = document.getElementById('victory-screen'); document.getElementById('winner-name').innerText = name; screen.style.display = 'flex'; }

    function drawPlayer(p, color, isMe) {
        ctx.save(); ctx.translate(p.x, p.y);
        ctx.fillStyle="#fff"; ctx.font="14px 'Tiny5'"; ctx.textAlign="center"; ctx.fillText(p.name, 0, -40);
        ctx.strokeStyle = "#000"; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0, 0, p.r, 0, 6.3); ctx.stroke();
        ctx.rotate(p.rot); ctx.fillStyle = color; ctx.beginPath(); ctx.arc(0, 0, p.r, 0, 6.3); ctx.fill();
        ctx.fillStyle="#000"; ctx.beginPath(); ctx.arc(7,-6,3,0,6.3); ctx.fill(); ctx.beginPath(); ctx.arc(-7,-6,3,0,6.3); ctx.fill();
        ctx.restore();
        ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(isMe ? myAngle : p.angle);
        const s = p.swing ? Math.sin(p.swing * 0.4) * 60 : 0; ctx.rotate(s * Math.PI / 180);
        ctx.fillStyle = color; ctx.strokeStyle="#000"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(42, 0, 10, 0, 6.3); ctx.fill(); ctx.stroke(); 
        const itm = isMe ? (ME.item?.name) : p.item;
        if(itm === 'SWORD') { ctx.fillStyle = "#d1d1d1"; ctx.fillRect(45, -6, 75, 12); ctx.strokeRect(45, -6, 75, 12); }
        else if(itm === 'STICK') { ctx.fillStyle = "#5d4037"; ctx.fillRect(45, -5, 55, 10); ctx.strokeRect(45, -5, 55, 10); }
        ctx.restore();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        bgCtx.fillStyle = "#0a0a0a"; bgCtx.fillRect(0,0,bgCanvas.width,bgCanvas.height);
        PLATFORMS.forEach(p => {
            if(p.y > canvas.height + 100) return;
            let shake = (p.contactTime > 180 && !p.falling) ? Math.sin(Date.now()*0.2)*6 : 0;
            ctx.fillStyle = "#1b1b1b"; ctx.fillRect(p.x+shake, p.y+40, p.w, p.h-40);
            ctx.fillStyle = "#3e2723"; ctx.fillRect(p.x+shake, p.y+20, p.w, 30);
            ctx.fillStyle = "#4caf50"; ctx.fillRect(p.x+shake, p.y, p.w, 15);
        });
        for(let x=-200; x<canvas.width+200; x+=40) {
            let flicker = Math.sin(magmaFrame*0.05 + x)*12;
            ctx.fillStyle = "#ff4500"; ctx.fillRect(x, MAGMA_Y + flicker, 42, 400);
        }
        projectiles.forEach(p => { ctx.fillStyle = (p.type==='NUKE')?"#222":"#fff"; ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, 6.3); ctx.fill(); });
        explosions.forEach(e => { ctx.fillStyle = `rgba(255, 69, 0, ${1 - e.r/e.max})`; ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, 6.3); ctx.fill(); });
        if(!isDead) drawPlayer(ME, ME.color, true); 
        Object.keys(players).forEach(id => { if(!players[id].dead) drawPlayer(players[id], players[id].color, false); });
    }

    function gameLoop() { update(); draw(); if(isGameRunning) requestAnimationFrame(gameLoop); }
    function showMenu(id) { document.querySelectorAll('.menu-screen').forEach(e => e.style.display = 'none'); document.getElementById(id).style.display = 'block'; }
    function updateUI() {
        document.getElementById('round-num').innerText = currentRound;
        document.getElementById('inv-slot').innerText = ME.item ? `${ME.item.name}\n${ME.item.ammo||''}` : "EMPTY";
    }
</script>
</body>
</html>
